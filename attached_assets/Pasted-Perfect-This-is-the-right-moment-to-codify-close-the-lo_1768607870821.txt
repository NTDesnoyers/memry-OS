Perfect. This is the right moment to codify, close the loop, and move forward deliberately.

I‚Äôll do all three, in explicit, execution-ready detail, in this order:
	1.	Cache Invalidation Convention (so this never happens again)
	2.	Formal Phase 1 ‚ÄúStable‚Äù Declaration + What Changes Operationally
	3.	Postmortem Note (for future-you and future contributors)

No abstraction. No fluff. This is operating doctrine.

‚∏ª

1Ô∏è‚É£ CACHE INVALIDATION CONVENTION (LOCK THIS IN)

The Problem You Just Solved (Restated Precisely)

You didn‚Äôt have a logic bug.
You didn‚Äôt have a backend bug.
You had a distributed contract bug:

The producer invalidated a cache key
The consumer listened to a different one

That means the system was correct but incoherent.

This will happen again unless you impose a rule.

‚∏ª

üîí THE CACHE LAW (NON-NEGOTIABLE)

Every API endpoint must define ONE canonical query key.
All reads AND all invalidations must reference that key.

No exceptions. No aliases. No ‚Äúclose enough.‚Äù

‚∏ª

‚úÖ THE FIX: CENTRALIZED QUERY KEY REGISTRY

Step 1: Create a single source of truth

Create a file:

// client/src/lib/queryKeys.ts
export const queryKeys = {
  signals: () => ["/api/signals"],
  generatedDrafts: () => ["/api/generated-drafts"],
  actions: () => ["/api/actions"],
  interactions: () => ["/api/interactions"],
  people: (personId?: string) =>
    personId
      ? ["/api/people", personId]
      : ["/api/people"],
};

Rules:
	‚Ä¢	Keys are functions, not constants (future-proofing)
	‚Ä¢	Strings match API routes exactly
	‚Ä¢	No inline array literals anywhere else in the app

‚∏ª

Step 2: Replace ALL queryKey usage

Everywhere you currently have:

queryKey: ["/api/generated-drafts"]

Replace with:

queryKey: queryKeys.generatedDrafts()

Same for invalidation:

queryClient.invalidateQueries({
  queryKey: queryKeys.generatedDrafts(),
});


‚∏ª

Step 3: Enforce via code review rule (important)

Rule you follow going forward:

‚ùå No inline query keys in components
‚úÖ Only queryKeys.*() allowed

This is how you prevent ghost bugs forever.

‚∏ª

Step 4: Add a comment where this bug happened

In signals.tsx, near the invalidation:

// IMPORTANT: Must invalidate the exact query key used by Drafts page.
// Mismatches here will cause actions to not appear.

This is institutional memory.

‚∏ª

2Ô∏è‚É£ PHASE 1 ‚ÄúSTABLE‚Äù DECLARATION (THIS IS A REAL THING)

You do not move on until you explicitly declare stability.

Here is the formal definition.

‚∏ª

‚úÖ PHASE 1 IS NOW CONSIDERED STABLE IF AND ONLY IF:

Core Invariants (Already Met)
	‚Ä¢	‚úî Every interaction creates a signal
	‚Ä¢	‚úî Signal creation is atomic
	‚Ä¢	‚úî No silent failures
	‚Ä¢	‚úî AI failure does not break correctness

Execution Invariants (Just Fixed)
	‚Ä¢	‚úî Signal resolution creates an action
	‚Ä¢	‚úî Action appears immediately
	‚Ä¢	‚úî Action persists after refresh
	‚Ä¢	‚úî Action can be deleted
	‚Ä¢	‚úî Cache invalidation is coherent

If all of the above are true ‚Üí Phase 1 is stable.

‚∏ª

üîÅ WHAT CHANGES OPERATIONALLY AFTER THIS DECLARATION

‚ùå What you stop doing
	‚Ä¢	No more foundational refactors
	‚Ä¢	No more ‚Äúmaybe this should be async‚Äù
	‚Ä¢	No more touching signal semantics
	‚Ä¢	No more cache experiments

‚úÖ What you start doing
	‚Ä¢	Demoing
	‚Ä¢	Dogfooding as a user, not a debugger
	‚Ä¢	Writing docs and onboarding
	‚Ä¢	Fixing only P2 confidence bugs
	‚Ä¢	Talking to potential users

üß† Mental Shift

You are no longer building the engine.
You are now driving the car.

This matters.

‚∏ª

üìå Add a Git commit / note (recommended)

Commit message:

Phase 1 stabilized: signal contract enforced, actions reliability fixed

This gives future-you a clean anchor point.

‚∏ª

3Ô∏è‚É£ POSTMORTEM NOTE (FOR FUTURE-YOU ‚Äî DO NOT SKIP)

Put this somewhere permanent:
	‚Ä¢	/docs/postmortems/2026-01-signal-actions.md
	‚Ä¢	or a Notion page
	‚Ä¢	or a comment block in the repo

Here‚Äôs the exact text you should use (edit names if you want):

‚∏ª

üìÑ POSTMORTEM: Signal ‚Üí Action Visibility Failure

Summary

Users reported that resolving a signal (e.g., clicking ‚ÄúText‚Äù) did not result in a visible action. Backend logic and database writes were correct, but the UI failed to update.

Root Cause

A React Query cache key mismatch:
	‚Ä¢	Signal resolution invalidated ["/api/drafts"]
	‚Ä¢	Drafts page queried ["/api/generated-drafts"]

As a result, the cache was never invalidated and the UI did not re-render.

Why This Was Dangerous
	‚Ä¢	The system did the correct work
	‚Ä¢	But appeared broken to the user
	‚Ä¢	This mimicked earlier trust-destroying bugs where ‚Äúnothing happened‚Äù

This was not a logic bug ‚Äî it was a contract violation between producer and consumer.

Fix
	‚Ä¢	Standardized on a single canonical query key
	‚Ä¢	Fixed invalidation to match the consumer
	‚Ä¢	Introduced a centralized queryKeys registry

Preventive Measures
	‚Ä¢	All query keys now live in queryKeys.ts
	‚Ä¢	Inline query keys are forbidden
	‚Ä¢	Every mutation must invalidate the exact consumer key

Key Lesson

Correctness is not enough.
Visibility is part of the contract.

If the user cannot see the result of their action immediately, the system is effectively lying ‚Äî even if the data is correct.

‚∏ª

This postmortem is gold. Most teams never write this down and re-learn the same lesson 6 months later.

‚∏ª

üîö FINAL STATE CHECK

You have now:
	‚Ä¢	Fixed correctness
	‚Ä¢	Fixed execution
	‚Ä¢	Fixed coherence
	‚Ä¢	Codified lessons
	‚Ä¢	Declared stability

This is what it feels like when a product snaps into place.

‚∏ª

NEXT OPTIONS (YOU‚ÄôRE READY FOR THESE NOW)

You can safely choose any of the following:
	1.	Phase 2 confidence fixes (contact updates, weekly review dates)
	2.	Onboarding + demo script
	3.	First pricing + beta rollout
	4.	Public build-in-public post (this story is compelling)

Say the word.